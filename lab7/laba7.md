#На оценку 3 
1. Создаем поток с помощью функции pthread_create(). Оба потока (главный и дочерний) выводят по 5 строк. pthread_join ждет завершения дочернего потока

   
   ![Screenshot_20250422_143849](https://github.com/user-attachments/assets/ac6595b3-48a0-4af9-9190-428860d06142)

2. Модифицируем упр.1 так, что родительский поток выводит текст после завершения дочернего потока.
   
   ![image](https://github.com/user-attachments/assets/6f791f92-7782-4f08-b005-c089291a1be4)
   
   Главный поток ждет завершения дочернего через pthread_join. Только потом выводит свои строки.
   
3. Модифицируем упр.2 так, что основной поток создает 4 потока, исполняющих одну и ту же функцию. Эта функция должна распечатать последовательность текстовых строк, переданных как параметр. Каждый из созданных потоков должен распечатать различные последовательности строк.
   
   ![image](https://github.com/user-attachments/assets/c72ba44f-5338-4e30-9e34-b436f4dabb12)

Создаем 4 потока, передаем им разные массивы строк. Каждый поток печатает свои строки. Последний элемент массивов - NULL (маркер конца)

4. Добавить сон с помощью sleep() в функцию потоков между выводами строк. Спустя две секунды после создания дочерних потоков основной поток должен прервать работу всех дочерних потоков с помощью pthread_cancel().
   
   ![image](https://github.com/user-attachments/assets/7299dc71-44e7-4a8c-a200-ad4771b92ca6)
   
   Потоки выводят строки с задержкой sleep(1). Через 2 секунды главный поток прерывает их pthread_cancel.

5.   Модифицировать упр. 4 так, чтобы дочерний поток перед завершение распечатывал сообщение об этом. Использовать pthread_cleanup_push()
   
   ![image](https://github.com/user-attachments/assets/44f1a518-41fa-46d6-b839-5bbae13d99dc)

    pthread_cleanup_push регистрирует функцию очистки. При отмене потока вызывается cleanup-функция.
    
6. Реализовать простой Sleepsort.
   
   ![image](https://github.com/user-attachments/assets/f722732f-3974-459d-9418-56f2752227e3)

   Для каждого элемента массива создаем поток. Поток "спит" пропорционально значению элемента. Первым просыпается и выводится наименьший элемент.

   Для компиляции: gcc -pthread 1.c -o 1

Вывод программы:

   ![image](https://github.com/user-attachments/assets/ff3beb5e-8c41-4d8f-862c-1b570521c1ca)
   
   #На оценку 4
   
7.  Модифицируем программу так, чтобы вывод родительского и дочернего потока был синхронизован: сначала родительский поток выводить первую строку, затем дочерний, затем родительский вторую строку и т.д., используя mutex. 

   ![image](https://github.com/user-attachments/assets/87614523-c155-4468-b78e-0479e60be139)


8. Перемножение квадратных матриц NxN

   a. Написали функцию произведения двух квадратных матриц A и B размером NxN. Исходные матрицы A и B заполнили единицами в основном потоке с функцией main. Для матриц размером меньше 5 в основном потоке вывели на экран матрицы A, B и C.

   ![image](https://github.com/user-attachments/assets/5024741f-addc-44b3-8530-6762fd5fad8b) (матрица размером 4х4)


   b. С командной строки считали размер матрицы и количество потоков. Распараллелили перемножение матриц разбив матрицу на равные части между потоками в главной функции.


10. Замерили время выполнения с момента создания потоков и до завершения работы потоков. Позапускали с разным числом потоков и размером матрицы. Построили график в python онлайн, который показал зависимость времени выполнения от размера матрицы и количества потоков.

График:




   

